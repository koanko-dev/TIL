# 데이터 프레임 
- 2차원 행렬 데이터에 인덱스를 붙인 것
- 행과 열로 만들어지는 2차원 배열 구조
- R의 데이터 프레임 에서 유래
- **데이프레임의 각 열은 시리즈로 구성되어 있음**
- DataFrame()함수를 사용해서 생성

read_[data_type]을 입력하면 데이터프레임이 생성되고, to_[data_type]을 입력하면 해당 파일로 변환된다.

## 데이터 프레임 생성
리스트로 데이터 프레임 만들기
- DataFrame([[list1],[list2]]) - 리스트 안에 리스트 형태로 인수를 전달(2차원 리스트 형태로 전달)
- 각 list는 한 행으로 구성됨
- 행의 원소 개수가 다르면 None 값으로 저장
- index 인수값이 없으면 기본 인덱스(위치 인덱스)가 생성됨

```python
df = pd.DataFrame([['a', 'b', 'c'], ['a', 'a', 'g'], ['a', 'g']])
df

    0	1	2
0	a	b	c
1	a	a	g
2	a	g	None
# 마지막 행의 원소 갯수가 다르기 때문에 None 값으로 저장된다.
```

```python
df = pd.DataFrame([['a', 'b', 'c'], ['a', 'a', 'g']])

len(df) # len 함수는 행의 갯수를 샌다
# 2

df.size # 원소의 갯수를 샌다. None도 포함.
# 6

df.shape # 행, 열의 갯수
# (2, 3)
```

## 딕셔너리로 데이터프레임 생성
열 데이터가 dict의 하나의 item과 매칭
딕셔너리의 key가 컬럼명으로 생성
```python
df1 = pd.DataFrame({
    'A':[90,80,70],
    'B':[85,98,75],
    'C':[88,99,77],                   
    'D':[87,89,86]
})
df1


    A	B	C	D
0	90	85	88	87
1	80	98	99	89
2	70	75	77	86
```

행 인덱스를 지정할 수 있다.
```python
df1 = pd.DataFrame({
    'A':[90,80,70],
    'B':[85,98,75],
    'C':[88,99,77],                   
    'D':[87,89,86]
}, index=[1, 2, 3])
df1


    A	B	C	D
1	90	85	88	87
2	80	98	99	89
3	70	75	77	86
```

## columns, index, values
DataFrame(data, index=명시적 행 index, columns=명시적 열 index)
columns를 사용해 열의 순서를 변경할 수 있다.
```python
data = {
    "2015": [9904312, 3448737, 2890451, 2466052],
    "2010": [9631482, 3393191, 2632035, 2000002],
    "2005": [9762546, 3512547, 2517680, 2456016],
    "2000": [9853972, 3655437, 2466338, 2473990],
    "지역": ["수도권", "경상권", "수도권", "경상권"],
    "2010-2015 증가율":[0.0283, 0.0163, 0.0982,0.0141]
}

df3 = pd.DataFrame(data)
df3

	2015	2010	2005	2000	지역	2010-2015 증가율
0	9904312	9631482	9762546	9853972	수도권	0.0283
1	3448737	3393191	3512547	3655437	경상권	0.0163
2	2890451	2632035	2517680	2466338	수도권	0.0982
3	2466052	2000002	2456016	2473990	경상권	0.0141

columns = ['지역','2000','2005','2010','2015', '2010-2015 증가율']
index = ['서울', '부산', '인천', '대구']
df3 = pd.DataFrame(data, index=index, columns=columns)
df3

	   지역	  2000	  2005	  2010	  2015	  2010-2015 증가율
서울	수도권	9853972	9762546	9631482	9904312	0.0283
부산	경상권	3655437	3512547	3393191	3448737	0.0163
인천	수도권	2466338	2517680	2632035	2890451	0.0982
대구	경상권	2473990	2456016	2000002	2466052	0.0141
```

데이터프레임의 속성 columns는 컬럼명을 저장하고 있음 - index 객체, 시리즈에는 없음
데이터프레임의 속성 index는 행 index 저장하고 있음 - index 객체
데이터프레임의 속성 values는 data값을 저장하고 있음 - array 객체
```python
df3.columns
# Index(['지역', '2000', '2005', '2010', '2015', '2010-2015 증가율'], dtype='object')

df3.index
# Index(['서울', '부산', '인천', '대구'], dtype='object')

df3.values
# array([['수도권', 9853972, 9762546, 9631482, 9904312, 0.0283],
#        ['경상권', 3655437, 3512547, 3393191, 3448737, 0.0163],
#        ['수도권', 2466338, 2517680, 2632035, 2890451, 0.0982],
#        ['경상권', 2473990, 2456016, 2000002, 2466052, 0.0141]], dtype=object)
```

실제로 저장될때는 표가 아닌 array 형태로 저장된다.

## csv 데이터로 부터 Dataframe 생성
 - 데이터 분석을 위해, dataframe을 생성하는 가장 일반적인 방법
 - 데이터 소스로부터 추출된 csv(comma separated values) 파일로부터 생성
 - pandas.read_csv('경로명/파일명(경로가 같으면 파일명만)') 함수 사용

데이터가 잘 들어왔는지 확인할 때 보통 head(), tail() 함수를 사용해 확인한다.
처음 5개행, 마지막 5개행만 출력하는 함수다.
```python
train_data = pd.read_csv('data/data/train.csv')

train_data.head() # 처음 5개행만 출력
train_data.tail() # 마지막 5개행만 출력

train_data.head(10) # 처음 10개행만 출력
train_data.tail(10) # 마지막 10개행만 출력
```

## 인덱스와 컬럼의 이해

1. 인덱스(index)
 - index 속성
 - 각 아이템(행)을 특정할 수 있는 고유의 값을 저장
 - 복잡한 데이터의 경우, 멀티 인덱스로 표현 가능

2. 컬럼(column)
 - columns 속성
 - 각각의 특성(feature)을 나타냄
 - 복잡한 데이터의 경우, 멀티 컬럼으로 표현 가능



## dataframe 데이터 파악하기
 - shape 속성 (row, column)
 - describe 함수 - 숫자형 데이터의 통계치 계산
 - info 함수 - 데이터 타입, 각 아이템의 개수 등 출력


### shape
```python
train_data.shape
# (891, 4)
```

### info()
```python
train_data.info()

# <class 'pandas.core.frame.DataFrame'>
# Int64Index: 891 entries, 1 to 891
# Data columns (total 4 columns):
#  #   Column    Non-Null Count  Dtype  
# ---  ------    --------------  -----  
#  0   Survived  891 non-null    int64  
#  1   Name      891 non-null    object 
#  2   Sex       891 non-null    object 
#  3   Age       714 non-null    float64
# dtypes: float64(1), int64(1), object(2)
# memory usage: 34.8+ KB
```

### describe()
수치형 데이터에 대해 기본 통계량 반환
```python
train_data.describe()

	    Survived	Age
count	891.000000	714.000000
mean	0.383838	29.699118
std	    0.486592    14.526497
min	    0.000000	0.420000
25%	    0.000000	20.125000
50%	    0.000000	28.000000
75%	    1.000000	38.000000
max	    1.000000	80.000000
```

## 데이터 프레임 전치
판다스 데이터 프레임은 전치를 포함해서 Numpy 2차원 배열의 대부분 속성이나 메서드를 지원함.
전치 : 행과 열을 바꾸는 기능
전치결과 반환하지 않음.
```python
df3

        지역	2000	2005	2010	2015	2010-2015 증가율
서울	수도권	9853972	9762546	9631482	9904312	0.0283
부산	경상권	3655437	3512547	3393191	3448737	0.0163
인천	수도권	2466338	2517680	2632035	2890451	0.0982
대구	경상권	2473990	2456016	2000002	2466052	0.0141

df3.T


                 서울	   부산	   인천    대구
지역	         수도권	    경상권	 수도권	  경상권
2000	        9853972	3655437	2466338	2473990
2005	        9762546	3512547	2517680	2456016
2010	        9631482	3393191	2632035	2000002
2015	        9904312	3448737	2890451	2466052
2010-2015 증가율	0.0283	0.0163	0.0982	0.0141
```

## 데이터 프레임 내용 변경

### 열 갱신, 추가
해당열이 있으면 내용 갱신, 열이 없으면 추가

갱신
```python
df3['2010-2015 증가율'] = df3['2010-2015 증가율'] * 100
df3

	    지역	2000	2005	2010	2015	2010-2015 증가율
서울	수도권	9853972	9762546	9631482	9904312	            2.83
부산	경상권	3655437	3512547	3393191	3448737	            1.63
인천	수도권	2466338	2517680	2632035	2890451	            9.82
대구	경상권	2473990	2456016	2000002	2466052	            1.41
```

추가        
```python
df3['비고'] = ['특별시', '광역시', '특례시', '특례시']
df3

	    지역	2000	2005	2010	2015	2010-2015 증가율	비고
서울	수도권	9853972	9762546	9631482	9904312	            2.83	특별시
부산	경상권	3655437	3512547	3393191	3448737	            1.63	광역시
인천	수도권	2466338	2517680	2632035	2890451	            9.82	특례시
대구	경상권	2473990	2456016	2000002	2466052	            1.41	특례시
```

삭제
```python
del df3['비고']
df3

	    지역	2000	2005	2010	2015	2010-2015 증가율
서울	수도권	9853972	9762546	9631482	9904312	            2.83
부산	경상권	3655437	3512547	3393191	3448737	            1.63
인천	수도권	2466338	2517680	2632035	2890451	            9.82
대구	경상권	2473990	2456016	2000002	2466052	            1.41
```

## 데이터 프레임 인덱싱
1. 열인덱싱(기본적으로 사용하는 인덱싱)
2. 인덱서를 사용하지않는 행 인덱싱
[]기호를 이용해서 인덱싱할때 주의점 : []기호는 열 위주 인덱싱이 원칙

### 1. 열인덱싱
#### 한개의 열 추출
- 기본 인덱싱 사용 : df명['컬럼명'] => 시리즈 반환됨
  ```python
  df3['지역']
  ```
- . 연산자로 추출: df명.컬럼명 => 시리즈 반환됨
  ```python
  df3.지역
  ```
- 전달되는 key 값을 집합적 자료형태(list등)로 전달 => 데이터프레임으로 반환
  ```python
  df3[['지역']]
  ```

#### 여러개의 열 추출
인덱스 값의 형태를 집합적 자료형태(list등)로 전달 => 데이터프레임으로 반환
```python
df3[['2010', '2015']]
```

#### 판다스 데이터 프레임에 열이름(컬럼명)이 문자열일 경우에는
수치 인덱스를 사용할 수 없음
위치 인덱싱 기능을 사용할 수 없다. : keyerror 발생
```python
try:
    df3[0]
except Exception as e:
    print(type(e))
# <class 'KeyError'>
```

```python
df5 = pd.DataFrame(np.arange(12).reshape(3,4))
df5

    0	1	2	3
0	0	1	2	3
1	4	5	6	7
2	8	9	10	11

df5[0]
0    0
1    4
2    8
Name: 0, dtype: int64
```
위의 코드에서 보면 위치 인덱싱을 사용한 것처럼 보이는데, 위치 인덱싱이 아닌 컬럼명이 0인 컬럼이 존재하기 때문에 에러가 발생하지 않고 결과가 나타난다.


### 2. 행 단위 인덱싱
슬라이싱으로만 가능
행단위 인덱싱을 하고자 하면 인덱서라는 특수 기능을 사용하지 않는 경우 슬라이싱을 해야 함(인덱서는 바로 뒤에 배움)
인덱스 값이 문자(라벨)면 문자슬라이싱도 가능하다.

```python
df3[:'서울']
        지역	2000	2005	2010	2015	2010-2015 증가율
서울	수도권	9853972	9762546	9631482	9904312	2.83

df3['부산':'인천']
	    지역	2000	2005	2010	2015	2010-2015 증가율
부산	경상권	3655437	3512547	3393191	3448737	1.63
인천	수도권	2466338	2517680	2632035	2890451	9.82

df3[0:0]
	지역	2000	2005	2010	2015	2010-2015 증가율

df3[0:1]
	지역	2000	2005	2010	2015	2010-2015 증가율
서울	수도권	9853972	9762546	9631482	9904312	2.83

df3[:1]
	지역	2000	2005	2010	2015	2010-2015 증가율
서울	수도권	9853972	9762546	9631482	9904312	2.83
```

#### 개별요소 접근 [열][행]
```python
df3['2015'] #시리즈 반환
서울    9904312
부산    3448737
인천    2890451
대구    2466052
Name: 2015, dtype: int64

df3['2015']['부산']
3448737

df3[['2015']] # 데이터프레임 반환
	    2015
서울	9904312
부산	3448737
인천	2890451
대구	2466052

df3[['2015']]['부산'] # 부산이라는 컬럼을 찾으라는 의미가 된다.
# KeyError
```
